parse_rest
==========

**parse_rest** is a Python client for the [Parse REST
  API](https://www.parse.com/docs/rest). It provides Python object
  mapping for Parse objects with methods to save, update, and delete
  objects, as well as an interface for querying stored objects.

Installation
------------

The easiest way to install this package is from
[PyPI](http://pypi.python.org/pypi), either using
[easy_install](http://packages.python.org/distribute/easy_install.html):

    easy_install parse_rest

or [pip](http://pypi.python.org/pypi/pip):

    pip install parse_rest

(if you are using a Mac or Linux system you may need to prepend `sudo`
to either command).

Alternatively, you can install it from source by downloading or
cloning this repository:

    git clone git@github.com:dgrtwo/ParsePy.git

and performing the commands:

    python setup.py build
    python setup.py install

(again you may have to add `sudo` before `python setup.py install`).

Testing
-------

To run the tests, you need to:

* create a `settings_local.py` file in your local directory with three
  variables that define a sample Parse application to use for testing:

~~~~~ {python}
APPLICATION_ID = "APPLICATION_ID_HERE"
REST_API_KEY = "REST_API_KEY_HERE"
MASTER_KEY = "MASTER_KEY_HERE"
~~~~~

* install the [Parse CloudCode command line
  tool](https://www.parse.com/docs/cloud_code_guide)

You can then test the installation by running:

    python setup.py test


Basic Usage
-----------

Let's get everything set up first. You'll need to give `parse_rest`
your Application Id and REST API Key (available from your Parse
dashboard) in order to get access to your data.

~~~~~ {python}
import parse_rest
parse_rest.APPLICATION_ID = "your application id"
parse_rest.REST_API_KEY = "your REST API key here"
~~~~~

To create a new object of the Parse class `GameScore`, you first
create such a class inheriting `parse_rest.Object`:

~~~~~ {python}
class GameScore(parse_rest.Object):
    pass
~~~~~

And then initialize it with your parameters:

~~~~~ {python}
gameScore = GameScore(score=1337, player_name='John Doe', cheat_mode=False)
~~~~~

You can change or set new parameters afterwards:

~~~~ {python}
gameScore.cheat_mode = True
gameScore.level = 20
~~~~

Supported data types are any type that can be serialized by JSON and
Python's _datetime.datetime_ object. (Binary data and references to
other _Object_'s are also supported, as we'll see in a minute.)

To save our new object, just call the save() method:

~~~~~ {python}
gameScore.save()
~~~~~

If we want to make an update, just call save() again after modifying
an attribute to send the changes to the server:

~~~~~ {python}
gameScore.score = 2061
gameScore.save()
~~~~~

You can also increment the score in a single API query:

~~~~~ {python}
gameScore.increment("score")
~~~~~

Now that we've done all that work creating our first Parse object, let's delete it:

~~~~~ {python}
gameScore.delete()
~~~~~

That's it! You're ready to start saving data on Parse.

Object Metadata
---------------

The attributes objectId, createdAt, and updatedAt show metadata about
a _Object_ that cannot be modified through the API:

~~~~~ {python}
gameScore.objectId
# 'xxwXx9eOec'
gameScore.createdAt
# datetime.datetime(2011, 9, 16, 21, 51, 36, 784000)
gameScore.updatedAt
# datetime.datetime(2011, 9, 118, 14, 18, 23, 152000)
~~~~~

Additional Datatypes
--------------------

If we want to store binary streams in a Object, we can use the parse_rest.Binary type:

~~~~~ {python}
gameScore.victoryImage = parse_rest.Binary('\x03\xf3\r\n\xc7\x81\x7fNc ... ')
~~~~~

We can also store geoPoint dataTypes, with latitude and longitude
as float values.

~~~~~ {python}
class Restaurant(parse_rest.Object):
    pass

restaurant = Restaurant(name="Los Pollos Hermanos")
restaurant.location = parse_rest.GeoPoint(latitude=12.0, longitude=-34.45)
restaurant.save()
~~~~~

We can store a reference to another Object by assigning it to an attribute:

~~~~~ {python}
class CollectedItem(parse_rest.Object):
    pass

collectedItem = CollectedItem(type="Sword", isAwesome=True)
collectedItem.save() # we have to save it before it can be referenced

gameScore.item = collectedItem
~~~~~


Querying
--------

Any class inheriting from `parse_rest.Object` has a `Query`
object. With it, you can perform queries that return a set of objects
or that will return a object directly.


=== Retrieving a single object ===

To retrieve an object with a Parse class of `GameScore` and an
`objectId` of `xxwXx9eOec`, run:

~~~~~ {python}
gameScore = GameScore.Query.get(objectId="xxwXx9eOec")
~~~~~

=== Working with Querysets ===

To query for sets of objects, we work with the concept of
`Queryset`s. If you are familiar with Django you will be right at home
- but be aware that is nnot a complete implementation of their
Queryset or Database backend.

The Query object contains a method called `all()`, which will return a
basic (unfiltered) Queryset. It will represent the set of all objects
of the class you are querying.

~~~~~ {python}
all_scores = GameScore.Query.all()
~~~~~

Querysets are _lazily evaluated_, meaning that it will only actually
make a request to Parse when you either call a method that needs to
operate on the data, or when you iterate on the Queryset.

==== Filtering ====

Querysets can be filtered:

~~~~~ {python}
high_scores = GameScore.Query.all().gte(score=1000)
~~~~~

The available filter functions are:

* **Less Than**
    * lt(**_parameters_)
* **Less Than Or Equal To**
    * lte(**_parameters_)
* **Greater Than**
    * gt(**_parameters_)
* **Greater Than Or Equal To**
    * gte(**_parameters_)
* **Not Equal To**
    * ne(**_parameters_)
* **Equal to**
    * eq(**_parameters_) // alias: where


**Warning**: We may change the way to use filtering functions in the
  near future, and favor a parameter-suffix based approach (similar to
  Django)
             

==== Sorting/Ordering ==== 

Querysets can also be ordered. Just define the name of the attribute
that you want to use to sort. Appending a "-" in front of the name
will sort the set in descending order. 

~~~~~ {python}
low_to_high_score_board = GameScore.Query.all().order_by("score")
high_to_low_score_board = GameScore.Query.all().order_by("-score") # or order_by("score", descending=True)
~~~~~

==== Limit/Skip ====

If you don't want the whole set, you can apply the
limit and skip function. Let's say you have a have classes
representing a blog, and you want to implement basic pagination:

~~~~~ {python}
posts = Post.Query.all().order_by("-publication_date")
page_one = posts.limit(10) # Will return the most 10 recent posts.
page_two = posts.skip(10).limit(10) # Will return posts 11-20
~~~~~

==== Composability/Chaining of Querysets ==== 

The example above can show the most powerful aspect of Querysets, that
is the ability to make complex querying and filtering by chaining calls:

Most importantly, Querysets can be chained together. This allows you
to make more complex queries:

~~~~~ {python}
posts_by_joe = Post.Query.all().where(author='Joe').order_by("view_count")
popular_posts = posts_by_joe.gte(view_count=200)
~~~~~

==== Iterating on Querysets ====

After all the querying/filtering/sorting, you will probably want to do
something with the results. Querysets can be iterated on:

~~~~~ {python}
posts_by_joe = Post.Query.all().where(author='Joe').order_by('view_count')
for post in posts_by_joe:
   print post.title, post.publication_date, post.text
~~~~~

**TODO**: Slicing of Querysets


Users
-----

You can sign up, log in, modify or delete users as well, using the `User` object. You sign a user up as follows:

~~~~~ {python}
u = parse_rest.User.signup("dhelmet", "12345", phone="555-555-5555")
~~~~~

or log in an existing user with

~~~~~ {python}
u = parse_rest.User.login("dhelmet", "12345")
~~~~~

Once a `User` has been logged in, it saves its session so that it can be edited or deleted:

~~~~~ {python}
u.highscore = 300
u.save()
u.delete()
~~~~~


Cloud Functions
---------------

Parse offers [CloudCode](https://www.parse.com/docs/cloud_code_guide), which has the ability to upload JavaScript functions that will be run on the server. You can use the `parse_rest` client to call those functions.

The CloudCode guide describes how to upload a function to the server. Let's say you upload the following `main.js` script:

~~~~~ {javascript}
Parse.Cloud.define("hello", function(request, response) {
  response.success("Hello world!");
});


Parse.Cloud.define("averageStars", function(request, response) {
  var query = new Parse.Query("Review");
  query.equalTo("movie", request.params.movie);
  query.find({
    success: function(results) {
      var sum = 0;
      for (var i = 0; i < results.length; ++i) {
        sum += results[i].get("stars");
      }
      response.success(sum / results.length);
    },
    error: function() {
      response.error("movie lookup failed");
    }
  });
});
~~~~~

Then you can call either of these functions using the `parse_rest.Function` class:

~~~~~ {python}
hello_func = parse_rest.Function("hello")
hello_func()
{u'result': u'Hello world!'}
star_func = parse_rest.Function("averageStars")
star_func(movie="The Matrix")
{u'result': 4.5}
~~~~~


That's it! This is a first try at a Python library for Parse, and is probably not bug-free. If you run into any issues, please get in touch -- dgrtwo@princeton.edu. Thanks!
